<!DOCTYPE html>
<html>

<head>
    <title>Universal Historical Quiz</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="../css/quiz-shared.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="../js/quiz_common.js"></script>
    <script src="../js/quiz_status.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            background: #fdf5e6;
        }

        #map-overlays {
            height: auto !important;
            min-height: 70px;
            display: flex !important;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            box-sizing: border-box;
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        .overlay {
            position: relative !important;
            margin: 5px;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.65) !important;
            backdrop-filter: blur(12px) !important;
            -webkit-backdrop-filter: blur(12px) !important;
            border: 1px solid rgba(255, 255, 255, 0.8) !important;
            border-top: 1px solid rgba(255, 255, 255, 1) !important;
            border-left: 1px solid rgba(255, 255, 255, 1) !important;
            border-radius: 12px !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05), 0 10px 15px rgba(0, 0, 0, 0.02) !important;
            color: #880e4f !important;
            font-weight: 700 !important;
            padding: 10px 18px !important;
            transition: all 0.3s ease;
        }

        .overlay:hover {
            background: rgba(255, 255, 255, 0.8) !important;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.08) !important;
            transform: translateY(-2px) !important;
        }

        .top-left {
            order: 1;
            border-left: 4px solid #e91e63 !important;
        }

        .top-right {
            order: 2;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #timer {
            background: rgba(233, 30, 99, 0.1);
            padding: 4px 10px;
            border-radius: 6px;
            color: #c2185b;
            font-weight: 700 !important;
        }

        .center-top {
            order: 3;
            width: 100%;
            margin-top: 10px !important;
            font-size: 20px !important;
            text-align: center;
            background: rgba(255, 255, 255, 0.75) !important;
            color: #ad1457 !important;
        }

        .center-top b {
            color: #d33a32;
            font-weight: 800;
            padding: 0 4px;
        }

        #map {
            height: calc(100vh - 120px) !important;
            background: #fdf5e6;
        }

        .medieval-icon {
            background: transparent;
            border: 0;
        }

        .medieval-icon svg {
            display: block;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.35));
        }

        .wrong-tooltip {
            background-color: #d33a32 !important;
            border: none !important;
            color: white !important;
            font-weight: bold;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            white-space: normal !important;
            max-width: 200px;
            text-align: center;
        }

        .wrong-tooltip .leaflet-tooltip-tip {
            border-top-color: #d33a32 !important;
        }

        .hint-tooltip {
            background-color: #fdf5e6 !important;
            border: 1px solid #ad1457 !important;
            color: #880e4f !important;
            font-weight: bold;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            padding: 4px 8px;
            opacity: 0.9 !important;
            white-space: normal !important;
            max-width: 180px;
            text-align: center;
        }

        .hint-tooltip .leaflet-tooltip-tip {
            border-top-color: #fdf5e6 !important;
        }

        .correct-persistent-tooltip {
            background-color: #e8f5e9 !important;
            border: 1px solid #1e9d46 !important;
            color: #0e6128 !important;
            font-weight: bold;
            padding: 4px 8px;
            font-size: 13px;
            font-weight: 600;
            z-index: 1000 !important;
            white-space: normal !important;
            max-width: 80vw;
            width: max-content;
            text-align: center;
        }

        .correct-persistent-tooltip .leaflet-tooltip-tip {
            border-bottom-color: #e8f5e9 !important;
            border-top-color: transparent !important;
        }

        @media (min-width: 800px) {
            #map-overlays {
                flex-wrap: nowrap;
                padding: 12px 25px;
            }

            .top-left {
                order: 1;
                flex: 1;
                text-align: left;
                max-width: fit-content;
            }

            .center-top {
                order: 2;
                flex: 2;
                width: auto;
                margin-top: 0 !important;
                font-size: 24px !important;
                padding: 12px 30px !important;
            }

            .top-right {
                order: 3;
                flex: 1;
                justify-content: flex-end;
            }

            #map {
                height: calc(100vh - 85px) !important;
            }
        }

        @media (max-width: 600px) {
            .overlay {
                padding: 8px 12px !important;
                font-size: 14px !important;
            }

            .center-top {
                font-size: 16px !important;
            }

            .top-left,
            .top-right {
                flex: 1;
                text-align: center;
                margin: 4px 2px;
                justify-content: center;
            }

            #map {
                height: calc(100vh - 145px) !important;
            }
        }
    </style>
</head>

<body>

    <div id="map-overlays">
        <div class="overlay top-left quiz-title-card">
            <a href="../index.html" class="back-btn title-back-btn" aria-label="Back to home" title="Back"><svg
                    viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                </svg></a>
            <span class="title-text">Historical Events</span>
        </div>
        <div id="score" class="overlay top-right">
            <span id="score-text">0%</span>
            <span id="timer" style="margin-left:12px;font-weight:400;font-size:15px;">0:00</span>
        </div>
        <div id="question" class="overlay center-top">Loading events...</div>
    </div>
    <div id="map"></div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const datasetParam = urlParams.get('dataset') || 'history_modal_rajasthan.geojson';
        const titleParam = urlParams.get('title') || 'Historical Events';
        const regionParam = urlParams.get('region') || 'rajasthan';

        document.title = titleParam + " Quiz";
        document.querySelector('.title-text').textContent = titleParam;

        let allData = [];
        let featureQuestions = [];
        let currentFeatureData = null;
        let totalQuestions = 0;
        let correctAnswers = 0;
        let geoLayer;
        let maxQuestions = 0;
        let attemptsLeft = 3;
        let attemptsCount = 0;
        let requireCorrectToAdvance = false;
        let correctFeatureForCurrent = null;
        let _lastCorrectFeature = null;
        let map = null;



        const rajasthanBounds = [
            [20.0, 55.0],
            [35.0, 90.0]
        ];
        const indiaBounds = [
            [6.0, 58.0],
            [38.0, 107.0]
        ];
        const activeBounds = regionParam === 'india' ? indiaBounds : rajasthanBounds;
        const initialZoomCenter = regionParam === 'india' ? [22.0, 79.0] : [27.0, 74.0];
        const initialZoomLevel = regionParam === 'india' ? 5 : 6;

        const MARKER_VISUALS = {
            default: { size: 20, fill: "#ffb74d", stroke: "#e65100" },
            hover: { size: 24, fill: "#ffa726", stroke: "#e65100" },
            correct: { size: 24, fill: "#1e9d46", stroke: "#0e6128" },
            wrong: { size: 24, fill: "#d33a32", stroke: "#8a1f1a" },
            target: { size: 28, fill: "#d33a32", stroke: "#8a1f1a" }
        };

        const VECTOR_VISUALS = {
            default: { color: "#ffb74d", weight: 3, opacity: 0.8, fillColor: "#ffb74d", fillOpacity: 0.4 },
            hover: { color: "#ffa726", weight: 4, opacity: 0.9, fillColor: "#ffa726", fillOpacity: 0.6 },
            correct: { color: "#1e9d46", weight: 4, opacity: 0.9, fillColor: "#1e9d46", fillOpacity: 0.5 },
            wrong: { color: "#d33a32", weight: 4, opacity: 0.9, fillColor: "#d33a32", fillOpacity: 0.5 },
            target: { color: "#d33a32", weight: 5, opacity: 1.0, fillColor: "#d33a32", fillOpacity: 0.6 }
        };

        function getMedievalIcon(state) {
            const visual = MARKER_VISUALS[state] || MARKER_VISUALS.default;
            const size = visual.size;
            return L.divIcon({
                className: 'medieval-icon',
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2],
                html:
                    '<svg width="' + size + '" height="' + size + '" viewBox="0 0 24 24" aria-hidden="true">' +
                    '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" fill="' + visual.fill + '" stroke="' + visual.stroke + '" stroke-width="1.5" stroke-linejoin="round"></path>' +
                    '<path d="M14 2v6h6" fill="none" stroke="' + visual.stroke + '" stroke-width="1.5" stroke-linejoin="round"></path>' +
                    '</svg>'
            });
        }

        function setFeatureState(layer, state, featureType) {
            if (featureType === 'Point') {
                layer.setIcon(getMedievalIcon(state));
            } else {
                layer.setStyle(VECTOR_VISUALS[state] || VECTOR_VISUALS.default);
            }
        }

        function resetFeatureStyle(layer, featureType) {
            setFeatureState(layer, 'default', featureType);
        }



        window.addEventListener('DOMContentLoaded', function () {
            fetch(`../data/geojson/${datasetParam}`)
                .then(response => response.json())
                .then(geojsonData => {
                    if (geojsonData && geojsonData.features && geojsonData.features.length > 0) {
                        allData = geojsonData.features;
                        initializeQuiz();
                    } else {
                        alert(`Invalid or empty ${datasetParam} file`);
                    }
                })
                .catch(error => {
                    alert(`Error loading ${datasetParam}: ` + error.message);
                });
        });

        function initializeQuiz() {
            map = L.map('map', {
                maxBounds: activeBounds,
                maxBoundsViscosity: 1.0
            }).setView(initialZoomCenter, initialZoomLevel);

            map.createPane('ripplePane');
            map.getPane('ripplePane').style.zIndex = 700;
            map.getPane('ripplePane').style.pointerEvents = 'none';

            const mapLayerUrl = regionParam === 'india' ? '../data/geojson/india_states.geojson' : '../data/geojson/india_districts.geojson';

            fetch(mapLayerUrl)
                .then(response => response.json())
                .then(statesData => {
                    let mapDataToDisplay = statesData;
                    // Filter specifically for Rajasthan boundaries if region is rajasthan
                    if (regionParam === 'rajasthan') {
                        mapDataToDisplay = {
                            "type": "FeatureCollection",
                            "features": statesData.features.filter(f => f.properties.st_nm === "Rajasthan")
                        };
                    }
                    L.geoJSON(mapDataToDisplay, {
                        interactive: false,
                        style: {
                            color: "#ad1457",
                            weight: 1.5,
                            opacity: 0.8,
                            fillOpacity: 0.05,
                            fillColor: "#f48fb1"
                        }
                    }).addTo(map);
                });

            // Extract all questions with IDs
            featureQuestions = allData.map((f, index) => {
                if (!f.properties.id) {
                    f.properties.id = 'feature_' + index;
                }
                return {
                    id: f.properties.id,
                    question: f.properties.question || 'Unknown event?',
                    hint: f.properties.hint || 'No hint',
                    brief: f.properties.brief || '',
                    geomType: f.geometry.type
                };
            });

            maxQuestions = featureQuestions.length;
            geoLayer = L.featureGroup();

            allData.forEach(feature => {
                let layer;
                if (feature.geometry.type === 'Point') {
                    const coords = feature.geometry.coordinates;
                    layer = L.marker([coords[1], coords[0]], {
                        icon: getMedievalIcon('default'),
                        keyboard: false
                    });
                } else {
                    layer = L.geoJSON(feature, {
                        style: VECTOR_VISUALS.default
                    });
                }

                if (feature.properties.hint) {
                    layer.bindTooltip(feature.properties.hint, {
                        permanent: true,
                        direction: 'top',
                        className: 'hint-tooltip',
                        offset: [0, -10]
                    });
                }

                layer.feature = feature;

                layer.on({
                    mouseover: function () {
                        if (layer === correctFeatureForCurrent) return;
                        setFeatureState(layer, 'hover', feature.geometry.type);
                    },
                    mouseout: function () {
                        if (layer === correctFeatureForCurrent) return;
                        resetFeatureStyle(layer, feature.geometry.type);
                    },
                    click: function (e) {
                        handleFeatureClick(layer, feature, e);
                    }
                });

                geoLayer.addLayer(layer);
            });

            geoLayer.addTo(map);
            try { map.fitBounds(geoLayer.getBounds(), { padding: [30, 30] }); } catch (err) { }

            startTimer();
            nextQuestion();
        }

        function getCenterOfLayer(layer, featureType) {
            if (featureType === 'Point') {
                return layer.getLatLng();
            } else {
                return layer.getBounds().getCenter();
            }
        }

        function handleFeatureClick(layer, feature, e) {
            const featureType = feature.geometry.type;
            const featureId = feature.properties.id;
            const clickPosition = e && e.latlng ? e.latlng : getCenterOfLayer(layer, featureType);

            // Clean up previous correct answer tooltip
            if (_lastCorrectFeature) {
                // Revert to hint-only tooltip
                _lastCorrectFeature.layer.unbindTooltip();
                _lastCorrectFeature.layer.bindTooltip(_lastCorrectFeature.hint, {
                    permanent: true,
                    direction: 'top',
                    className: 'hint-tooltip',
                    offset: [0, -10]
                });
                resetFeatureStyle(_lastCorrectFeature.layer, _lastCorrectFeature.featureType);
                _lastCorrectFeature = null;
            }

            attemptsCount++;

            if (featureId === currentFeatureData.id) {
                correctAnswers++;
                playCorrectSound();
                updateScore();
                setFeatureState(layer, 'correct', featureType);
                triggerCelebration(clickPosition);

                // Update to detailed tooltip showing the brief as a bulleted list
                let details = "Correct!";
                if (feature.properties.brief) {
                    const points = feature.properties.brief.split(';').map(p => p.trim()).filter(p => p);
                    if (points.length > 1) {
                        details = '<ul style="text-align: left; margin: 0; padding-left: 14px;">' +
                            points.map(p => '<li style="margin-bottom: 1px;">' + p + '</li>').join('') +
                            '</ul>';
                    } else {
                        details = feature.properties.brief;
                    }
                }

                layer.bindTooltip(details, {
                    permanent: true,
                    direction: 'bottom',
                    offset: [0, 8],
                    className: 'correct-persistent-tooltip'
                }).openTooltip();

                // Keep tooltip visible until next answer
                _lastCorrectFeature = {
                    layer: layer,
                    hint: feature.properties.hint,
                    featureType: featureType
                };

                nextQuestion();
                return;
            }

            playIncorrectSound();
            updateScore();

            if (requireCorrectToAdvance) {
                setFeatureState(layer, 'wrong', featureType);
                setTimeout(() => resetFeatureStyle(layer, featureType), 1200);

                // Show temporary wrong tooltip, keep existing hint
                layer.unbindTooltip();
                layer.bindTooltip("Incorrect: " + feature.properties.hint, {
                    permanent: false,
                    className: 'wrong-tooltip',
                    direction: 'top',
                    offset: [0, -10]
                }).openTooltip(clickPosition);

                setTimeout(() => {
                    layer.closeTooltip();
                    layer.unbindTooltip();
                    layer.bindTooltip(feature.properties.hint, {
                        permanent: true,
                        direction: 'top',
                        className: 'hint-tooltip',
                        offset: [0, -10]
                    });
                }, 1200);
                return;
            }

            attemptsLeft = Math.max(0, attemptsLeft - 1);
            if (attemptsLeft > 0) {
                setFeatureState(layer, 'wrong', featureType);
                setTimeout(() => resetFeatureStyle(layer, featureType), 2000);

                // Show temporary wrong tooltip, keep existing hint
                layer.unbindTooltip();
                layer.bindTooltip("Incorrect: " + feature.properties.hint, {
                    permanent: false,
                    className: 'wrong-tooltip',
                    direction: 'top',
                    offset: [0, -10]
                }).openTooltip(clickPosition);

                setTimeout(() => {
                    layer.closeTooltip();
                    layer.unbindTooltip();
                    layer.bindTooltip(feature.properties.hint, {
                        permanent: true,
                        direction: 'top',
                        className: 'hint-tooltip',
                        offset: [0, -10]
                    });
                }, 1200);
            } else {
                let correctLayer = null;
                let correctFeatureType = 'Point';

                geoLayer.eachLayer(function (lyr) {
                    if (lyr.feature.properties.id === currentFeatureData.id) {
                        correctLayer = lyr;
                        correctFeatureType = lyr.feature.geometry.type;
                    }
                });

                if (correctLayer) {
                    let on = true;
                    const iv = setInterval(() => {
                        setFeatureState(correctLayer, on ? 'wrong' : 'default', correctFeatureType);
                        on = !on;
                    }, 250);

                    setTimeout(() => {
                        clearInterval(iv);
                        requireCorrectToAdvance = true;
                        correctFeatureForCurrent = correctLayer;
                        setFeatureState(correctLayer, 'target', correctFeatureType);

                        const center = getCenterOfLayer(correctLayer, correctFeatureType);
                        triggerRippleAt(center, '#d33a32');

                        // Force update question banner
                        setQuestion("Click on the highlighted marker...", totalQuestions, maxQuestions, true);
                    }, 2000);
                } else {
                    nextQuestion();
                }
            }
        }



        function nextQuestion() {
            requireCorrectToAdvance = false;
            if (correctFeatureForCurrent) {
                resetFeatureStyle(correctFeatureForCurrent, correctFeatureForCurrent.feature.geometry.type);
                correctFeatureForCurrent = null;
            }

            if (maxQuestions > 0 && totalQuestions >= maxQuestions) {
                endQuiz();
                return;
            }

            if (!featureQuestions || featureQuestions.length === 0) {
                endQuiz();
                return;
            }

            const idx = Math.floor(Math.random() * featureQuestions.length);
            currentFeatureData = featureQuestions.splice(idx, 1)[0];
            attemptsLeft = 3;
            totalQuestions++;

            setQuestion(currentFeatureData.question, totalQuestions, maxQuestions);
        }

        function updateScore() {
            let percentage = attemptsCount === 0 ? 0 : Math.round((correctAnswers / attemptsCount) * 100);
            document.getElementById("score-text").innerHTML = percentage + "%";
        }

        function endQuiz() {
            stopTimer();
            const percent = attemptsCount === 0 ? 0 : Math.round((correctAnswers / attemptsCount) * 100);
            if (typeof saveStandaloneQuizResult === 'function') saveStandaloneQuizResult(percent, totalQuestions || 0, correctAnswers || 0);
            document.getElementById("question").innerHTML = "Quiz finished! Final score: <b>" + percent + "%</b>";

            if (geoLayer) {
                geoLayer.eachLayer(function (layer) {
                    layer.off();
                });
            }

            const restart = document.createElement('button');
            restart.textContent = 'Restart Quiz';
            restart.style.cssText = 'margin-left:15px; padding:5px 12px; border-radius:4px; border:1px solid #ad1457; background:#fff; color:#ad1457; cursor:pointer; font-weight:bold;';
            restart.onclick = function () { location.reload(); };
            const q = document.getElementById('question');
            if (q) q.appendChild(restart);
        }

    </script>
</body>

</html>